#pragma config(Sensor, port2,  colorSensor,    sensorVexIQ_ColorHue)
#pragma config(Motor,  motor1,          leftDrive,     tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor5,          rightDrive,    tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor6,          revolver,      tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor10,         dumper,        tmotorVexIQ, PIDControl, reversed, encoder)
#pragma config(Motor,  motor11,         fifthWheel,    tmotorVexIQ, PIDControl, encoder)
#pragma config(Motor,  motor12,         conveyor,      tmotorVexIQ, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

enum color
{
		red = 0,
		green = 1,
		blue = 2,
};

const int minChannelValue = 20;
const float minColorRatio = 1.15;
const int minTimeIntervalForColorChangeDeciSec = 9.6;
const color initialRevolverColor = green;
const int horizontalDriveKickInBoundary = 50;
const int horizontalDrivePowerReduction = 20;
const float forwardSpeedReductionCoefficient = 0.5;
const int revolverLowGearSpeed = 20;
const int revolverHighGearSpeed = 40;


void setDriveMotorsState()
{
		bool isHorizontalDrive = abs(vexRT[ChC]) > horizontalDriveKickInBoundary;

		if (isHorizontalDrive == true)
		{
				if (vexRT[ChC] > 0)
				{
						motor[fifthWheel] = vexRT[ChC] - horizontalDrivePowerReduction;
				}
				else
				{
						motor[fifthWheel] = vexRT[ChC] + horizontalDrivePowerReduction;
				}

				motor[leftDrive] = 0;
				motor[rightDrive] = 0;
		}
		else
		{
				motor[fifthWheel] = 0;

				motor[leftDrive] = vexRT[ChA] * forwardSpeedReductionCoefficient;
				motor[rightDrive] = vexRT[ChD] * forwardSpeedReductionCoefficient;
		}
}

void setConveyorBeltMotorState(bool* pIsRevolverInAutoMode)
{
		if (vexRT[BtnRDown] == true && vexRT[BtnRUp] == true)
		{
				motor[conveyor] = 0;
				*pIsRevolverInAutoMode = false;
		}
		else if (vexRT[BtnRDown] == true)
		{
				motor[conveyor] = 100;
				//motor[conveyor] = 20;
				*pIsRevolverInAutoMode = true;
		}
		else if (vexRT[BtnRUp] == true)
		{
				motor[conveyor] = -100;
				//motor[conveyor] = 0;
				*pIsRevolverInAutoMode = false;
		}
}

void setRevolverMotorStateInManualMode(bool* pIsRevolverInAutoMode)
{
		int increment = 0;
		if (vexRT[BtnFUp] == true)
		{
				increment = 1;
		}
		if (vexRT[BtnFDown] == true)
		{
				increment = -1;
		}

		if (increment != 0)
		{
				*pIsRevolverInAutoMode = false;
				motor[conveyor] = 0;

				int stepCount = ((int)(getMotorEncoder(revolver) + 20)) / 60;
				stepCount += increment;

				setMotorTarget(revolver,  stepCount * 60, revolverHighGearSpeed);
		}
		else
		{
				static int previousFineAdjustmentSpeed = 0;
				int fineAdjustmentSpeed = 0;
				if (vexRT[BtnEUp] == true)
				{
						fineAdjustmentSpeed = revolverLowGearSpeed;
				}
				else if (vexRT[BtnEDown] == true)
				{
						fineAdjustmentSpeed = -revolverLowGearSpeed;
				}

				if (fineAdjustmentSpeed != 0)
				{
						*pIsRevolverInAutoMode = false;
						motor[conveyor] = 0;
						motor[revolver] = fineAdjustmentSpeed;
				}
				else if (previousFineAdjustmentSpeed != 0)
				{
						motor[revolver] = 0;
						resetMotorEncoder(revolver);
				}

				previousFineAdjustmentSpeed = fineAdjustmentSpeed;
		}
}

int max(int first, int second)
{
		if (first > second)
				return first;
		else
				return second;
}

void setRevolverMotorStateInAutoMode()
{
		// Limit to 1 in order to prevent divide by zero errors.
		//
		int blueChannel = max(1, getColorBlueChannel(port2));
		int redChannel = max(1, getColorRedChannel(port2));
		int greenChannel = max(1, getColorGreenChannel(port2));

		// writeDebugStreamLine("%3d    %3d     %3d", redChannel, greenChannel, blueChannel);

		static color currentRevolverColor = initialRevolverColor;
		static color lastSeenSensorColor = currentRevolverColor;

		if (blueChannel > redChannel && blueChannel > greenChannel
				&& blueChannel > minChannelValue
				&& blueChannel / (float)(redChannel) > minColorRatio && blueChannel / (float)(greenChannel) > minColorRatio)
		{
				//writeDebugStreamLine("blue");
				lastSeenSensorColor = blue;

		}
		else if (redChannel > blueChannel && redChannel > greenChannel
						 && redChannel > minChannelValue
						 && redChannel / (float)(blueChannel) > minColorRatio && redChannel / (float)(greenChannel) > minColorRatio)
		{
				//writeDebugStreamLine("red");
				lastSeenSensorColor = red;
		}
		else if (greenChannel > blueChannel && greenChannel > redChannel
						 && greenChannel > minChannelValue
						 && greenChannel / (float)(blueChannel) > minColorRatio && greenChannel / (float)(redChannel) > minColorRatio)
		{
				//writeDebugStreamLine("green");
				lastSeenSensorColor = green;
		}

		static int colorDifference = 0;
		if (lastSeenSensorColor != currentRevolverColor && time100[T1] > minTimeIntervalForColorChangeDeciSec)
		{
			  colorDifference = (int)currentRevolverColor - (int)lastSeenSensorColor;
				if (colorDifference < 0)
				{
						colorDifference += 3;
				}

				resetMotorEncoder(revolver);
				if (colorDifference == 1)
				{
						setMotorTarget(revolver, 120, 100);
				}
				else
				{
						setMotorTarget(revolver, -120, 100);
				}

				currentRevolverColor = lastSeenSensorColor;

				// T1 measures time since last color change.
				// Color shouldn't change too often, to allow previous ring to be
				// deposited on revolver.
				// Clear T1 when we do change revolver color.
				//
				clearTimer(T1);
		}

}

void setDumperMotorState()
{
		if (vexRT[BtnLUp] == true)
		{
				motor[dumper] = 100;
		}
		else if (vexRT[BtnLDown] == true)
		{
				motor[dumper] = -100;
		}
		else
		{
				motor[dumper] = 0;
		}
}

task main()
{
		setColorMode(port2, colorTypeRGB_Hue_Reflected);
		bool isRevolverInAutoMode = false;
		clearTimer(T1);

		while (true)
		{
			setDriveMotorsState();
			setConveyorBeltMotorState(&isRevolverInAutoMode);
			setRevolverMotorStateInManualMode(&isRevolverInAutoMode);
			if (isRevolverInAutoMode == true)
			{
					setRevolverMotorStateInAutoMode();
			}
			setDumperMotorState();
		}
}
